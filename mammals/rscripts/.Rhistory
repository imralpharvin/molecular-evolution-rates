setwd("C:/Users/RalphArvin/Desktop/work-s2018/mammals/rscripts")
#For data manipulation:
#install.packages("data.table")
library(data.table)
# For importing xslx data to data.frame
#install.packages("readxl")
library("readxl")
source("GetTraitSpecificDataBIN.R")
source("GetTraitSpecificData.R")
source("GetTraitInfo.R")
### TRAIT: MEDIAN LATITUDE ###
# Currently, median latitude is the only trait whose information is taken from BOLD. The rest of the data will be obtained from FishBase.
#1. Filtering for presence of a latitude value.
dfLatitudeSpecies <- dfFiltered[grep("[0-9]", lat)]
#2. Convert the latitude (lat) column to number instead of character type
dfLatitudeSpecies[, lat_num := as.numeric(lat)]
#3. Conversion to absolute values before median latitude values are calculated.
dfLatitudeSpecies[, abs_lat_num := abs(lat_num)]
#4. Determine a median latitude for each BIN using absolute values.
dfLatitudeSpecies[, median_lat := median(abs_lat_num), keyby = bin_uri]
# While considering traits for eventual multivariate analyses, it is necessary for them to have an adequate sample size
# (i.e. over x # rows of data, depending on your purposes). In addition, they should exhibit some amount of variation across the observations.
# Use the GetTraitSpecificDataBIN function to obtain a subset of data for those species that have latitude data available.
#5. Get the trait specific datatable.
dfLatitude <- setDT(GetTraitSpecificDataBIN(dfLatitudeSpecies, 16))
#6. Get information for the trait.
GetTraitInfo(dfLatitude, "median_lat", type = "continuous")
#7. Datatable reorganization for dfFiltered.
dfFiltered <- dfFiltered[, .(bin_uri, filtered_bin_size, recordID, order_name = order_label, family_name = family_label, genus_name = genus_label,
species_name = species_label, nucleotides)]
### TRAIT: PANTHERIA XLSX ###
#1.Reading the data to variable allMammals
rawMammalData <- read_excel("Pantheria.xlsx")
#2.Select traits by column and store it in a vector
selectedTraits <- c("MSW05_Order","MSW05_Family","MSW05_Genus","MSW05_Binomial", "5-1_AdultBodyMass_g","8-1_AdultForearmLen_mm","18-1_BasalMetRate_mLO2hr",  "15-1_LitterSize", "17-1_MaxLongevity_m", "23-1_SexualMaturityAge_d", "10-2_SocialGrpSize","12-1_HabitatBreadth","6-1_DietBreadth", "6-2_TrophicLevel", "1-1_ActivityCycle" )
#3.Filter the original data using the selectedTraits vector as the subset
traitData <- rawMammalData[selectedTraits]
#4.Renaming columns
colnames(traitData) <- c("order", "family", "genus", "species_name", "AdultBodyMass(g)", "AdultForearmLength(mm)", "BasalMetRate(mLO2hr)","LitterSize", "MaxLongevity(months)", "SexualMaturityAge(days)", "SocialGrpSize", "HabitatBreadth", "DietBreadth", "TrophicLevel", "ActivityCycle")
#5.Changing -999 values to NA
traitData[traitData == -999] <- NA
#6 Converting to data table
traitData <- as.data.table(traitData)
#7 Merge Species name
mergedSpecies <- merge(dfFiltered, traitData, by = "species_name")
#7 single row per species
dfFilteredSingle <- dfFiltered[!duplicated(species_name)][, .(bin_uri, species_name, filtered_bin_size)]
#8 Merge with latitude
dfTraits <- merge(dfFilteredSingle, dfLatitude, all = T, by = "bin_uri")
#9
dfTraits <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfTraits, traitData))
#10
dfTraits<- dfTraits[!is.na(bin_uri)]
#11
dfTraits <- dfTraits[, c(1:3, 6:20)]
#12
missing <- dfTraits[, apply(.SD, 1, function(x) all(is.na(x))), .SDcols = 4:13]
missing <- which(missing == TRUE)
dfTraits <-dfTraits[!missing]
dfPreCentroid <- merge(dfFiltered, dfTraits, by = "bin_uri")[, 1:8]
dfPreCentroid<- dfPreCentroid[,c(7,1,2,3,4,5,6,8)]
# Dataframe reorganization and renaming.
setnames(dfPreCentroid, "species_name.x", "species_name")
rm(selectedTraits, missing); rm(dfLatitude, dfLatitudeSpecies, mergedSpecies, rawMammalData, dfFilteredSingle, dfResolve)
View(dfPreCentroid)
save.image("C:/Users/RalphArvin/Desktop/pantheria/Sec 2 June 14.RData")
# # Copyright (C) 2018 Jacqueline May.
# Program Description: Multivariable analysis of environmental and biological correlates affecting fish molecular evolution rates.
# Contributions & Acknowledgements #
# Dr. Sarah J. Adamowicz and Dr. Zeny Feng for help with designing and structuring the pipeline.
# Centroid sequence selection designed by Matt Orton (https://github.com/m-orton/R-Scripts).
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# There is a copy of the GNU General Public License along with this program in the repository where it is located.
# Or view it directly here at http://www.gnu.org/licenses/
#############################################################################################################################
##### SECTION 3: CENTROID SEQUENCE DETERMINATION #####
# This section is designed to select a centroid sequence for each BIN. A centroid sequence is the sequence in a BIN with minimum sum of pairwise
# distance to all other sequences in the BIN. It will serve as a representative sequence for the BIN/species.
setwd("C:/Users/RalphArvin/Desktop/work-s2018/mammals/rscripts")
### PACKAGES REQUIRED ###
# For data manipulation:
#install.packages("data.table")
library(data.table)
# For multiple sequence alignments:
#install.packages("ape")
library(ape)
#source("https://bioconductor.org/biocLite.R")
#biocLite("Biostrings")
library(Biostrings)
#biocLite("muscle")
library(muscle)
#install.packages("foreach")
library(foreach)
# Load the function(s) designed for this script:
source("RefSeqTrim.R")
#############################################################################################################################
# Subset dataframe to find BINs with more than one sequence.
dfLargeBins <- dfPreCentroid[filtered_bin_size > 1]
# If there is at least one BIN with more than one sequence...
if (nrow(dfLargeBins) > 0) {
# Remove gaps from the sequences.
dfPreCentroid[, nucleotides := gsub("-", "", nucleotides)]
# Subset out the BINs with more than 1 sequence.
dfCentroidSeqs <- dfPreCentroid[bin_uri %in% dfLargeBins$bin_uri]
# We also have to create another separate dataframe with BINs that only have one sequence, called dfSingletons.
dfSingletons <- dfPreCentroid[!bin_uri %in% dfLargeBins$bin_uri]
# We then take the dfCentroidSeqs sequences and group them by BIN.
largeBinList <- split(dfCentroidSeqs, by = "bin_uri")
# Convert all the sequences in largeBinList to DNAStringSet format for
# the multiple sequence alignment.
DNAStringSetList <- lapply(largeBinList, function(x) DNAStringSet(x$nucleotides))
# Name DNAStringSetList using the recordIDs.
for (i in seq(from = 1, to = length(unique(dfCentroidSeqs$bin_uri)), by = 1)) {
names(DNAStringSetList[[i]]) <- largeBinList[[i]]$recordID
}
# Align the sequences in each BIN using MUSCLE.
alignmentList <- lapply(DNAStringSetList, function(x) muscle::muscle(x, diags = TRUE, gapopen = -3000))
# Convert each BIN alignment to DNAbin format.
alignmentList <- lapply(alignmentList, function(x) as.DNAbin(x))
# Estimates the genetic distance between sequences in each BIN with the TN93 model.
distanceMatrixList <- lapply(alignmentList, function(x) dist.dna(x, model = "TN93", as.matrix = TRUE, pairwise.deletion = TRUE))
# Find the centroid sequence using the genetic distance matrix. It is the sequence in a BIN with minimum average pairwise distance to all other sequences in the BIN.
centroidSeqs <- sapply(distanceMatrixList, function(x) which.min(rowSums(x)))
centroidSeqs <- names(centroidSeqs)
centroidSeqs <- gsub("^.*\\.", "", centroidSeqs)
centroidSeqs <- as.numeric(centroidSeqs)
# Subset dfCentroidSeqs by the recordIDs of the centroid sequences.
dfCentroidSeqs <- dfCentroidSeqs[dfCentroidSeqs$recordID %in% centroidSeqs]
# Combine the singletons and centroid sequences into a new dataframe. Now each BIN has a representative sequence.
dfCentroidSeqs <- rbind(dfCentroidSeqs, dfSingletons)
} else {
# Centroid sequence selection not required if all BINs are singletons.
dfCentroidSeqs <- dfPreCentroid
}
View(dfTraits)
