View(dfFiltered)
load("C:/Users/RalphArvin/Desktop/work-s2018/fishbase/Sec 4 June 14.RData")
load("C:/Users/RalphArvin/Desktop/work-s2018/mammals/pantheria/June 22/Sec 2 June 22.RData")
View(dfTraits)
load("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 1 June 22.RData")
load("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/rscripts/Sec5.R")
load("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 4b July 04.RData")
View(dfTraits)
mainTree <- read.tree(file = "bootstrap_example.tree")
temp <- 1
while( temp <= length(mainTree$tip.label)){
mainTree$tip.label[temp] <- dfCentroidSeqsNO$species_name[as.numeric(mainTree$tip.label[temp])]
temp = temp + 1;
}
# Root the tree using your chosen outgroup species.
mainTree <- root(mainTree, outgroup = "Tachyglossus aculeatus", resolve.root = T)
### TRAIT: NUMBER OF NODES.
# Match mainTree with data subset. This will ensure the tree has only the tips we need for data analysis.
dfTraits <- dfTraits[match(mainTree$tip.label, dfTraits$species_name), ]
dfTraits[, number_of_nodes := distRoot(mainTree, method = "nNodes")]
### TRAIT: BRANCH LENGTHS.
# Let's calculate the sum of branch lengths now (from root to tip). These values will serve as our measurement of molecular evolution rate.
dfTraits[, branch_length := distRoot(mainTree, method = "patristic")]
# Get info about the branch lengths.
GetTraitInfo(dfTraits$branch_length)
# Range within which 95% of the values fall.
quantile(dfTraits$branch_length, probs = c(.025, .975))
# Take a closer look at branch length outliers. Some contaminated sequences might have STILL gotten through, so it is best to check!
# Using the IQR to detect statistical outliers.
lowerQuantile <- quantile(dfTraits$branch_length)[2]
upperQuantile <- quantile(dfTraits$branch_length)[4]
iqr <- upperQuantile - lowerQuantile
upperThreshold <- (iqr * 3) + upperQuantile
lowerThreshold <-  lowerQuantile - (iqr * 3)
# Extreme short branches.
dfShort <- dfTraits[branch_length < lowerThreshold][, c(1, 50:51)]
# Get the sequence information in case you want to BLAST the sequence (also, we aren't interested in outgroup species here,
# that's why we are using dfCentroidSeqsNO).
dfShort <- merge(dfShort, dfCentroidSeqsNO, by = "species_name")
# Do the same for the extreme long branches.
dfLong <- dfTraits[branch_length > upperThreshold][, c(1, 50:51)]
dfLong <- merge(dfLong, dfCentroidSeqsNO, by = "species_name")
# Remove from dataset, if desired.
dfTraits <- RemoveSequences(dfTraits, c(dfShort$species_name, dfLong$species_name))
load("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 4b June 27.RData")
setwd("C:/Users/imralpharvin/Desktop/work-s2018/mammalsb/rscripts")
library(data.table)
# For phylogenetic tree manipulation and analysis:
#install.packages("adephylo")
library(adephylo)
#install.packages("ape")
library(ape)
#install.packages("caper")
library(caper)
#install.packages("phytools")
library(phytools)
# For statistical analysis/graphs:
#install.packages("car")
library(car)
#install.packages("plotly")
library(plotly)
#install.packages("Rmisc")
library(Rmisc)
# Load the function(s) designed for this script:
#install.packages("devtools")
library(devtools)
#install_github("helixcn/phylotools")
library(phylotools)
source("GetTraitInfo.R")
source("TestPhyloSig.R")
source("PGLS.R")
source("MergeAndPGLS.R")
#############################################################################################################################
# A phylogenetic tree containing branch length data for your species is required for this section.
# Read in your phylogenetic tree.
mainTree <- read.tree(file = "bootstrap_example.tree")
temp <- 1
while( temp <= length(mainTree$tip.label)){
mainTree$tip.label[temp] <- dfCentroidSeqsNO$species_name[as.numeric(mainTree$tip.label[temp])]
temp = temp + 1;
}
# Root the tree using your chosen outgroup species.
mainTree <- root(mainTree, outgroup = "Tachyglossus aculeatus", resolve.root = T)
### TRAIT: NUMBER OF NODES.
# Match mainTree with data subset. This will ensure the tree has only the tips we need for data analysis.
dfTraits <- dfTraits[match(mainTree$tip.label, dfTraits$species_name), ]
dfTraits[, number_of_nodes := distRoot(mainTree, method = "nNodes")]
### TRAIT: BRANCH LENGTHS.
# Let's calculate the sum of branch lengths now (from root to tip). These values will serve as our measurement of molecular evolution rate.
dfTraits[, branch_length := distRoot(mainTree, method = "patristic")]
# Get info about the branch lengths.
GetTraitInfo(dfTraits$branch_length)
# Range within which 95% of the values fall.
quantile(dfTraits$branch_length, probs = c(.025, .975))
# Take a closer look at branch length outliers. Some contaminated sequences might have STILL gotten through, so it is best to check!
# Using the IQR to detect statistical outliers.
lowerQuantile <- quantile(dfTraits$branch_length)[2]
upperQuantile <- quantile(dfTraits$branch_length)[4]
iqr <- upperQuantile - lowerQuantile
upperThreshold <- (iqr * 3) + upperQuantile
lowerThreshold <-  lowerQuantile - (iqr * 3)
# Extreme short branches.
dfShort <- dfTraits[branch_length < lowerThreshold][, c(1, 50:51)]
# Get the sequence information in case you want to BLAST the sequence (also, we aren't interested in outgroup species here,
# that's why we are using dfCentroidSeqsNO).
dfShort <- merge(dfShort, dfCentroidSeqsNO, by = "species_name")
# Do the same for the extreme long branches.
dfLong <- dfTraits[branch_length > upperThreshold][, c(1, 50:51)]
dfLong <- merge(dfLong, dfCentroidSeqsNO, by = "species_name")
# Remove from dataset, if desired.
dfTraits <- RemoveSequences(dfTraits, c(dfShort$species_name, dfLong$species_name))
load("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 4b June 27.RData")
setwd("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/rscripts")
library(data.table)
# For phylogenetic tree manipulation and analysis:
#install.packages("adephylo")
library(adephylo)
#install.packages("ape")
library(ape)
#install.packages("caper")
library(caper)
#install.packages("phytools")
library(phytools)
# For statistical analysis/graphs:
#install.packages("car")
library(car)
#install.packages("plotly")
library(plotly)
#install.packages("Rmisc")
library(Rmisc)
# Load the function(s) designed for this script:
#install.packages("devtools")
library(devtools)
#install_github("helixcn/phylotools")
library(phylotools)
source("GetTraitInfo.R")
source("TestPhyloSig.R")
source("PGLS.R")
source("MergeAndPGLS.R")
#############################################################################################################################
# A phylogenetic tree containing branch length data for your species is required for this section.
# Read in your phylogenetic tree.
mainTree <- read.tree(file = "bootstrap_example.tree")
temp <- 1
while( temp <= length(mainTree$tip.label)){
mainTree$tip.label[temp] <- dfCentroidSeqsNO$species_name[as.numeric(mainTree$tip.label[temp])]
temp = temp + 1;
}
# Root the tree using your chosen outgroup species.
mainTree <- root(mainTree, outgroup = "Tachyglossus aculeatus", resolve.root = T)
### TRAIT: NUMBER OF NODES.
# Match mainTree with data subset. This will ensure the tree has only the tips we need for data analysis.
dfTraits <- dfTraits[match(mainTree$tip.label, dfTraits$species_name), ]
dfTraits[, number_of_nodes := distRoot(mainTree, method = "nNodes")]
### TRAIT: BRANCH LENGTHS.
# Let's calculate the sum of branch lengths now (from root to tip). These values will serve as our measurement of molecular evolution rate.
dfTraits[, branch_length := distRoot(mainTree, method = "patristic")]
# Get info about the branch lengths.
GetTraitInfo(dfTraits$branch_length)
# Range within which 95% of the values fall.
quantile(dfTraits$branch_length, probs = c(.025, .975))
# Take a closer look at branch length outliers. Some contaminated sequences might have STILL gotten through, so it is best to check!
# Using the IQR to detect statistical outliers.
lowerQuantile <- quantile(dfTraits$branch_length)[2]
upperQuantile <- quantile(dfTraits$branch_length)[4]
iqr <- upperQuantile - lowerQuantile
upperThreshold <- (iqr * 3) + upperQuantile
lowerThreshold <-  lowerQuantile - (iqr * 3)
# Extreme short branches.
dfShort <- dfTraits[branch_length < lowerThreshold][, c(1, 50:51)]
# Get the sequence information in case you want to BLAST the sequence (also, we aren't interested in outgroup species here,
# that's why we are using dfCentroidSeqsNO).
dfShort <- merge(dfShort, dfCentroidSeqsNO, by = "species_name")
# Do the same for the extreme long branches.
dfLong <- dfTraits[branch_length > upperThreshold][, c(1, 50:51)]
dfLong <- merge(dfLong, dfCentroidSeqsNO, by = "species_name")
# Remove from dataset, if desired.
dfTraits <- RemoveSequences(dfTraits, c(dfShort$species_name, dfLong$species_name))
View(mainTree)
mainTree$tip.label
load("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 4 June 27.RData")
setwd("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/rscripts")
#install.packages("ape")
#install.packages("phangorn")
#install.packages("seqinr")
#source("https://bioconductor.org/biocLite.R")
#biocLite("Biostrings")
library(ape)
library(phangorn)
library(seqinr)
library(Biostrings)
#Converting data table to DNAStringSet object
mammalDSA <- DNAStringSet(dfCentroidSeqsNO$nucleotides)
#Write dna file for dna string set
write.dna(mammalDSA, "mammals.DNA")
#Read  dna file
mammals <- read.dna("mammals.dna", format="interleaved")
#DNA to phyDAT format
mammals_phyDat <- phyDat(mammals, type = "DNA", levels = NULL)
#Compute pairwise distance
dm <- dist.ml(mammals_phyDat, model="JC69")
#NJ tree estimation
mammals_NJ  <- NJ(dm)
#Plot NJ tree
plot(mammals_NJ, main = "Neighbor Joining")
#Write Tree
write.tree(mammals_NJ, file="bootstrap_example.tree")
setwd("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/rscripts")
library(data.table)
# For phylogenetic tree manipulation and analysis:
#install.packages("adephylo")
library(adephylo)
#install.packages("ape")
library(ape)
#install.packages("caper")
library(caper)
#install.packages("phytools")
library(phytools)
# For statistical analysis/graphs:
#install.packages("car")
library(car)
#install.packages("plotly")
library(plotly)
#install.packages("Rmisc")
library(Rmisc)
# Load the function(s) designed for this script:
#install.packages("devtools")
library(devtools)
#install_github("helixcn/phylotools")
library(phylotools)
source("GetTraitInfo.R")
source("TestPhyloSig.R")
source("PGLS.R")
source("MergeAndPGLS.R")
#############################################################################################################################
# A phylogenetic tree containing branch length data for your species is required for this section.
# Read in your phylogenetic tree.
mainTree <- read.tree(file = "bootstrap_example.tree")
temp <- 1
while( temp <= length(mainTree$tip.label)){
mainTree$tip.label[temp] <- dfCentroidSeqsNO$species_name[as.numeric(mainTree$tip.label[temp])]
temp = temp + 1;
}
# Root the tree using your chosen outgroup species.
mainTree <- root(mainTree, outgroup = "Tachyglossus aculeatus", resolve.root = T)
### TRAIT: NUMBER OF NODES.
# Match mainTree with data subset. This will ensure the tree has only the tips we need for data analysis.
dfTraits <- dfTraits[match(mainTree$tip.label, dfTraits$species_name), ]
dfTraits[, number_of_nodes := distRoot(mainTree, method = "nNodes")]
### TRAIT: BRANCH LENGTHS.
# Let's calculate the sum of branch lengths now (from root to tip). These values will serve as our measurement of molecular evolution rate.
dfTraits[, branch_length := distRoot(mainTree, method = "patristic")]
load("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 4b June 27.RData")
save.image("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 4b July 6.RData")
library(data.table)
# For phylogenetic tree manipulation and analysis:
#install.packages("adephylo")
library(adephylo)
#install.packages("ape")
library(ape)
#install.packages("caper")
library(caper)
#install.packages("phytools")
library(phytools)
# For statistical analysis/graphs:
#install.packages("car")
library(car)
#install.packages("plotly")
library(plotly)
#install.packages("Rmisc")
library(Rmisc)
# Load the function(s) designed for this script:
#install.packages("devtools")
library(devtools)
#install_github("helixcn/phylotools")
library(phylotools)
source("GetTraitInfo.R")
source("TestPhyloSig.R")
source("PGLS.R")
source("MergeAndPGLS.R")
#############################################################################################################################
# A phylogenetic tree containing branch length data for your species is required for this section.
# Read in your phylogenetic tree.
mainTree <- read.tree(file = "bootstrap_example.tree")
temp <- 1
while( temp <= length(mainTree$tip.label)){
mainTree$tip.label[temp] <- dfCentroidSeqsNO$species_name[as.numeric(mainTree$tip.label[temp])]
temp = temp + 1;
}
# Root the tree using your chosen outgroup species.
mainTree <- root(mainTree, outgroup = "Tachyglossus aculeatus", resolve.root = T)
### TRAIT: NUMBER OF NODES.
# Match mainTree with data subset. This will ensure the tree has only the tips we need for data analysis.
dfTraits <- dfTraits[match(mainTree$tip.label, dfTraits$species_name), ]
dfTraits[, number_of_nodes := distRoot(mainTree, method = "nNodes")]
### TRAIT: BRANCH LENGTHS.
# Let's calculate the sum of branch lengths now (from root to tip). These values will serve as our measurement of molecular evolution rate.
dfTraits[, branch_length := distRoot(mainTree, method = "patristic")]
# Get info about the branch lengths.
GetTraitInfo(dfTraits$branch_length)
# Range within which 95% of the values fall.
quantile(dfTraits$branch_length, probs = c(.025, .975))
# Take a closer look at branch length outliers. Some contaminated sequences might have STILL gotten through, so it is best to check!
# Using the IQR to detect statistical outliers.
lowerQuantile <- quantile(dfTraits$branch_length)[2]
upperQuantile <- quantile(dfTraits$branch_length)[4]
iqr <- upperQuantile - lowerQuantile
upperThreshold <- (iqr * 3) + upperQuantile
lowerThreshold <-  lowerQuantile - (iqr * 3)
# Extreme short branches.
dfShort <- dfTraits[branch_length < lowerThreshold][, c(1, 50:51)]
# Get the sequence information in case you want to BLAST the sequence (also, we aren't interested in outgroup species here,
# that's why we are using dfCentroidSeqsNO).
dfShort <- merge(dfShort, dfCentroidSeqsNO, by = "species_name")
# Do the same for the extreme long branches.
dfLong <- dfTraits[branch_length > upperThreshold][, c(1, 50:51)]
dfLong <- merge(dfLong, dfCentroidSeqsNO, by = "species_name")
# Remove from dataset, if desired.
dfTraits <- RemoveSequences(dfTraits, c(dfShort$species_name, dfLong$species_name))
mainTree <- drop.tip(phy = mainTree, tip = mainTree$tip.label[!mainTree$tip.label %in% dfTraits$species_name])
dfTraits <- dfTraits[match(mainTree$tip.label, dfTraits$species_name), ]
### SINGLE-VARIABLE PGLS ANALYSES ###
# Use the PGLS function to perform single-variable (with number of nodes as a control variable) for all of the traits.
# e.g. branch_length ~ trait_of_interest + number_of_nodes
# We will do this by looping through all of the columns containing the trait data using lapply.
traits <- as.list(colnames(dfTraits[,4:44]))
# Set to dataframe.
dfTraits <- as.data.frame(dfTraits)
# Start the loop.
singleVarResults <- lapply(traits, function(x) {
# We only want the columns containing species name and dependent and independent variables.
data <- dfTraits[, c("species_name", x, "branch_length", "number_of_nodes")]
# Remove NA values.
data <- data[complete.cases(data), ]
# Perform PGLS. The trait of interest in this case will always be the 2nd column.
caper <- PGLS(data, mainTree, branch_length ~ data[, 2] + number_of_nodes)
# Take the summary of the results.
caperSum <- summary(caper)
})
# Assign names to the list of results based on the trait of interest.
names(singleVarResults) <- traits
View(dfTraits)
load("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 4b July 6.RData")
View(dfTraits)
load("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 3 July 04.RData")
View(dfTraits)
load("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 4 July 04.RData")
View(dfTraits)
load("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 4b July 04.RData")
View(dfTraits)
load("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 4 July 04.RData")
View(dfTraits)
setwd("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/rscripts")
#install.packages("ape")
#install.packages("phangorn")
#install.packages("seqinr")
#source("https://bioconductor.org/biocLite.R")
#biocLite("Biostrings")
library(ape)
library(phangorn)
library(seqinr)
library(Biostrings)
#Converting data table to DNAStringSet object
mammalDSA <- DNAStringSet(dfCentroidSeqsNO$nucleotides)
#Write dna file for dna string set
write.dna(mammalDSA, "mammals.DNA")
#Read  dna file
mammals <- read.dna("mammals.dna", format="interleaved")
#DNA to phyDAT format
mammals_phyDat <- phyDat(mammals, type = "DNA", levels = NULL)
#Compute pairwise distance
dm <- dist.ml(mammals_phyDat, model="JC69")
#NJ tree estimation
mammals_NJ  <- NJ(dm)
#Plot NJ tree
plot(mammals_NJ, main = "Neighbor Joining")
#Write Tree
write.tree(mammals_NJ, file="bootstrap_example.tree")
save.image("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 4b2 July 06.RData")
View(dfTraits)
setwd("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/rscripts")
library(data.table)
# For phylogenetic tree manipulation and analysis:
#install.packages("adephylo")
library(adephylo)
#install.packages("ape")
library(ape)
#install.packages("caper")
library(caper)
#install.packages("phytools")
library(phytools)
# For statistical analysis/graphs:
#install.packages("car")
library(car)
#install.packages("plotly")
library(plotly)
#install.packages("Rmisc")
library(Rmisc)
# Load the function(s) designed for this script:
#install.packages("devtools")
library(devtools)
#install_github("helixcn/phylotools")
library(phylotools)
source("GetTraitInfo.R")
source("TestPhyloSig.R")
source("PGLS.R")
source("MergeAndPGLS.R")
#############################################################################################################################
# A phylogenetic tree containing branch length data for your species is required for this section.
# Read in your phylogenetic tree.
mainTree <- read.tree(file = "bootstrap_example.tree")
temp <- 1
while( temp <= length(mainTree$tip.label)){
mainTree$tip.label[temp] <- dfCentroidSeqsNO$species_name[as.numeric(mainTree$tip.label[temp])]
temp = temp + 1;
}
# Root the tree using your chosen outgroup species.
mainTree <- root(mainTree, outgroup = "Tachyglossus aculeatus", resolve.root = T)
### TRAIT: NUMBER OF NODES.
# Match mainTree with data subset. This will ensure the tree has only the tips we need for data analysis.
dfTraits <- dfTraits[match(mainTree$tip.label, dfTraits$species_name), ]
dfTraits[, number_of_nodes := distRoot(mainTree, method = "nNodes")]
### TRAIT: BRANCH LENGTHS.
# Let's calculate the sum of branch lengths now (from root to tip). These values will serve as our measurement of molecular evolution rate.
dfTraits[, branch_length := distRoot(mainTree, method = "patristic")]
# Get info about the branch lengths.
GetTraitInfo(dfTraits$branch_length)
# Range within which 95% of the values fall.
quantile(dfTraits$branch_length, probs = c(.025, .975))
# Take a closer look at branch length outliers. Some contaminated sequences might have STILL gotten through, so it is best to check!
# Using the IQR to detect statistical outliers.
lowerQuantile <- quantile(dfTraits$branch_length)[2]
upperQuantile <- quantile(dfTraits$branch_length)[4]
iqr <- upperQuantile - lowerQuantile
upperThreshold <- (iqr * 3) + upperQuantile
lowerThreshold <-  lowerQuantile - (iqr * 3)
# Extreme short branches.
dfShort <- dfTraits[branch_length < lowerThreshold][, c(1, 50:51)]
# Get the sequence information in case you want to BLAST the sequence (also, we aren't interested in outgroup species here,
# that's why we are using dfCentroidSeqsNO).
dfShort <- merge(dfShort, dfCentroidSeqsNO, by = "species_name")
# Do the same for the extreme long branches.
dfLong <- dfTraits[branch_length > upperThreshold][, c(1, 50:51)]
dfLong <- merge(dfLong, dfCentroidSeqsNO, by = "species_name")
# Remove from dataset, if desired.
dfTraits <- RemoveSequences(dfTraits, c(dfShort$species_name, dfLong$species_name))
mainTree <- drop.tip(phy = mainTree, tip = mainTree$tip.label[!mainTree$tip.label %in% dfTraits$species_name])
dfTraits <- dfTraits[match(mainTree$tip.label, dfTraits$species_name), ]
### SINGLE-VARIABLE PGLS ANALYSES ###
# Use the PGLS function to perform single-variable (with number of nodes as a control variable) for all of the traits.
# e.g. branch_length ~ trait_of_interest + number_of_nodes
# We will do this by looping through all of the columns containing the trait data using lapply.
traits <- as.list(colnames(dfTraits[,4:44]))
# Set to dataframe.
dfTraits <- as.data.frame(dfTraits)
# Start the loop.
singleVarResults <- lapply(traits, function(x) {
# We only want the columns containing species name and dependent and independent variables.
data <- dfTraits[, c("species_name", x, "branch_length", "number_of_nodes")]
# Remove NA values.
data <- data[complete.cases(data), ]
# Perform PGLS. The trait of interest in this case will always be the 2nd column.
caper <- PGLS(data, mainTree, branch_length ~ data[, 2] + number_of_nodes)
# Take the summary of the results.
caperSum <- summary(caper)
})
View(dfTraits)
traits <- as.list(colnames(dfTraits[,4:29,31:44]))
# Set to dataframe.
dfTraits <- as.data.frame(dfTraits)
# Start the loop.
singleVarResults <- lapply(traits, function(x) {
# We only want the columns containing species name and dependent and independent variables.
data <- dfTraits[, c("species_name", x, "branch_length", "number_of_nodes")]
# Remove NA values.
data <- data[complete.cases(data), ]
# Perform PGLS. The trait of interest in this case will always be the 2nd column.
caper <- PGLS(data, mainTree, branch_length ~ data[, 2] + number_of_nodes)
# Take the summary of the results.
caperSum <- summary(caper)
})
# Assign names to the list of results based on the trait of interest.
names(singleVarResults) <- traits
sigVars <- lapply(singleVarResults, function(x) (x$coefficients[2,4]))
names(sigVars) <- names(singleVarResults)
# Which are below 0.15?
keepVars <- names(which(sigVars <= 0.15))
keepVars <- c("species_name", "branch_length", "number_of_nodes", keepVars)
View(singleVarResults)
traits <- as.list(colnames(dfTraits[, 31:44]))
# Set to dataframe.
dfTraits <- as.data.frame(dfTraits)
# Start the loop.
singleVarResults <- lapply(traits, function(x) {
# We only want the columns containing species name and dependent and independent variables.
data <- dfTraits[, c("species_name", x, "branch_length", "number_of_nodes")]
# Remove NA values.
data <- data[complete.cases(data), ]
# Perform PGLS. The trait of interest in this case will always be the 2nd column.
caper <- PGLS(data, mainTree, branch_length ~ data[, 2] + number_of_nodes)
# Take the summary of the results.
caperSum <- summary(caper)
})
# Assign names to the list of results based on the trait of interest.
names(singleVarResults) <- traits
# Which traits have p-values 0.15 or below?
# For now, this is only taking the first p-value of the trait (I still need to change it to deal with multi-level factors).
sigVars <- lapply(singleVarResults, function(x) (x$coefficients[2,4]))
names(sigVars) <- names(singleVarResults)
# Which are below 0.15?
keepVars <- names(which(sigVars <= 0.15))
keepVars <- c("species_name", "branch_length", "number_of_nodes", keepVars)
