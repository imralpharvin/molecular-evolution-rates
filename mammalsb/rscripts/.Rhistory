dfTrait<- dfTrait[!is.na(home_range_indiv)]
dfHomeRangeIndividual <- dfTrait[,!c(2:3)]
#### TRAIT: POPULATION DENSITY ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "pop_density")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(pop_density)]
dfPopulationDensity <- dfTrait[,!c(2:3)]
#### TRAIT: POPULATION GROUP SIZE ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "pop_grpsize")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(pop_grpsize)]
dfPopulationGroupSize <- dfTrait[,!c(2:3)]
#### TRAIT: SOCIAL GROUP SIZE ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "social_grpsize")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(social_grpsize)]
dfSocialGroupSize <- dfTrait[,!c(2:3)]
#### TRAIT: MEDIAN LATITUDE ####
# Conversion to absolute values before median latitude values are calculated.
dfLatitudeSpecies[, abs_lat_num := abs(lat_num)]
# Determine a median latitude for each BIN using absolute values.
dfLatitudeSpecies[, median_lat := median(abs_lat_num), keyby = bin_uri]
#### TRAIT: LATITUDE RANGE ####
# Get maximum latitude for each bin
dfLatitudeSpecies[, max_lat := max(lat_num), keyby = bin_uri]
# Get minimum latitude for each bin
dfLatitudeSpecies[, min_lat := min(lat_num), keyby = bin_uri]
# Subtract maximum latitude and minimum latitude
dfLatitudeSpecies[, range_lat := max_lat - min_lat, keyby = bin_uri]
# Datatable organization
dfLatitudeSpecies <- dfLatitudeSpecies[, !c(14,15,17,18)]
# Get the trait specific datatable.
dfLatitudeMedian <- setDT(GetTraitSpecificDataBIN(dfLatitudeSpecies, 14))
dfLatitudeRange <- setDT(GetTraitSpecificDataBIN(dfLatitudeSpecies, 15))
# Datatable reorganization
setnames(dfLatitudeMedian, "species_label", "species_name")
setnames(dfLatitudeRange, "species_label", "species_name")
dfFiltered <- dfFiltered[, .(bin_uri, filtered_bin_size, recordID, order_name = order_label, family_name = family_label, genus_name = genus_label,
species_name = species_label, nucleotides)]
dfLatitudeMedian <- dfLatitudeMedian[, !c(1,3)]
dfLatitudeRange <- dfLatitudeRange[, !c(1,3)]
#### TRAIT: GR AREA ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "GR_area")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(GR_area)]
dfGrArea <- dfTrait[,!c(2:3)]
#### TRAIT: GR MAXIMUM LATITUDE ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "GR_maxlat")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(GR_maxlat)]
dfGrMaxLat <- dfTrait[,!c(2:3)]
#### TRAIT: GR MINIMUM LATITUDE ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "GR_minlat")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(GR_minlat)]
dfGrMinLat <- dfTrait[,!c(2:3)]
#### TRAIT: GR MIDDLE RANGE LATITUDE ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "GR_midrangelat")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(GR_midrangelat)]
dfGrMidRangeLat <- dfTrait[,!c(2:3)]
#### TRAIT: GR MAXIMUM LONGITUDE ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "GR_maxlong")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(GR_maxlong)]
dfGrMaxLong <- dfTrait[,!c(2:3)]
#### TRAIT: GR MINIMUM LONGITUDE ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "GR_minlong")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(GR_minlong)]
dfGrMinLong <- dfTrait[,!c(2:3)]
#### TRAIT: GR MID RANGE LONGITUDE ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "GR_midrangelong")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(GR_midrangelong)]
dfGrMidRangeLong <- dfTrait[,!c(2:3)]
#### TRAIT: HUMAN POPULATION DENSITY MINIMUM ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "hupopden_min")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(hupopden_min)]
dfHumanPopulationMin <- dfTrait[,!c(2:3)]
#### TRAIT: HUMAN POPULATION DENSITY MEAN ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "hupopden_mean")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(hupopden_mean)]
dfHumanPopulationMean <- dfTrait[,!c(2:3)]
#### TRAIT: HUMAN POPULATION DENSITY 5p ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "hupopden_5p")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(hupopden_5p)]
dfHumanPopulation5p <- dfTrait[,!c(2:3)]
#### TRAIT: HUMAN POPULATION DENSITY CHANGE ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "hupopden_change")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(hupopden_change)]
dfHumanPopulationChange <- dfTrait[,!c(2:3)]
#### TRAIT: PRECIPITATION MEAN ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "precip_mean")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(precip_mean)]
dfPrecipitationMean <- dfTrait[,!c(2:3)]
#### TRAIT: Temperature Mean ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "temp_mean")]
anageTrait <- anageMammalData[, c("species_name", "temp_mean")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait , anageTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
missingbm <- dfTrait[, apply(.SD, 1, function(x) all(is.na(x))), .SDcols = 4:5]
missingbm <- which(missingbm == TRUE)
dfTrait <-dfTrait[!missingbm]
dfTrait$temp_mean=rowMeans(dfTrait[,c(4:5)], na.rm=TRUE)
dfTemperatureMean <- dfTrait[,!c(2:5)]
#### TRAIT:AET MEAN ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "AET_mean")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(AET_mean)]
dfAETMean <- dfTrait[,!c(2:3)]
#### TRAIT:PET MEAN ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "PET_mean")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(PET_mean)]
dfPETMean <- dfTrait[,!c(2:3)]
#### TRAIT:ACTIVITY CYCLE ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "activity_cycle")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(activity_cycle)]
dfTrait$activity_cycle <- as.factor(dfTrait$activity_cycle)
dfActivityCycle <- dfTrait[,!c(2:3)]
#### TRAIT:DIET BREADTH ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "diet_breadth")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(diet_breadth)]
dfTrait$diet_breadth <- as.factor(dfTrait$diet_breadth)
dfDietBreadth <- dfTrait[,!c(2:3)]
#### TRAIT:HABITAT BREADTH ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "habitat_breadth")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(habitat_breadth)]
dfTrait$habitat_breadth <- as.factor(dfTrait$habitat_breadth)
dfHabitatBreadth <- dfTrait[,!c(2:3)]
#### TRAIT:TERRESTRIALITY ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "terrestriality")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(terrestriality)]
dfTrait$terrestriality <- as.factor(dfTrait$terrestriality)
dfTerrestriality <- dfTrait[,!c(2:3)]
#### TRAIT:TROPHIC LEVEL ####
pantheriaTrait <- pantheriaMammalData[, c("species_name", "trophic_level")]
dfTrait <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, pantheriaTrait))
dfTrait<- dfTrait[!is.na(bin_uri)]
dfTrait<- dfTrait[!is.na(trophic_level)]
dfTrait$trophic_level <- as.factor(dfTrait$trophic_level)
dfTrophicLevel <- dfTrait[,!c(2:3)]
######################################################################################################################
#### Merging traits ####
dfTraits <- Reduce(function(...) merge(..., all = T, by = "species_name"), list(dfFilteredSingle, dfBodyMass, dfForearmLength, dfHeadBodyLength, dfEyeOpeningAge, dfBmrRate, dfBmrMass, dfMaxLongevity, dfSexualMaturityAge, dfAdultSvlLength, dfMaturityLength, dfGrowthRate, dfImrPerYear,dfMrdt, dfMetabolicRate, dfFirstBirthAge, dfGestationLength, dfInterbirthInterval, dfLitterSize, dfLittersPerYear, dfNeonateBodyMass, dfNeonateHeadBodyLength, dfNeonateSvlLength, dfTeatNumber, dfWeaningAge, dfWeaningBodyMass, dfWeaningBodyLength, dfDispersalAge, dfHomeRange, dfHomeRangeIndividual, dfPopulationDensity, dfPopulationGroupSize, dfSocialGroupSize, dfLatitudeMedian, dfLatitudeRange, dfGrArea, dfGrMaxLat, dfGrMinLat, dfGrMidRangeLat, dfGrMaxLong, dfGrMinLong, dfGrMidRangeLong, dfHumanPopulationMin, dfHumanPopulationMean, dfHumanPopulation5p, dfHumanPopulationChange, dfPrecipitationMean, dfTemperatureMean, dfAETMean, dfPETMean, dfActivityCycle, dfDietBreadth, dfHabitatBreadth, dfTerrestriality, dfTrophicLevel))
dfTraits<- dfTraits[!is.na(bin_uri)]
missing <- dfTraits[, apply(.SD, 1, function(x) all(is.na(x))), .SDcols = 4:54]
missing <- which(missing == TRUE)
dfTraits <-dfTraits[!missing]
dfTraits[diet_breadth == "8", diet_breadth := NA][, diet_breadth := droplevels(diet_breadth)]
GetTraitInfo(dfTraits$body_mass)
GetTraitInfo(dfTraits$forearm_length)
GetTraitInfo(dfTraits$headbody_length)
GetTraitInfo(dfTraits$eyeopening_age)
GetTraitInfo(dfTraits$bmr_rate)
GetTraitInfo(dfTraits$bmr_mass)
GetTraitInfo(dfTraits$max_longevity)
GetTraitInfo(dfTraits$sexualmaturity_age)
GetTraitInfo(dfTraits$adult_svl_length)
GetTraitInfo(dfTraits$maturity_length)
GetTraitInfo(dfTraits$growth_rate)
GetTraitInfo(dfTraits$imr_pyear)
GetTraitInfo(dfTraits$mrdt)
GetTraitInfo(dfTraits$metabolic_rate)
GetTraitInfo(dfTraits$firstbirth_age)
GetTraitInfo(dfTraits$gestation_length)
GetTraitInfo(dfTraits$litter_size)
GetTraitInfo(dfTraits$litters_pyear)
GetTraitInfo(dfTraits$neonate_bodymass)
GetTraitInfo(dfTraits$neonate_headbodylength)
GetTraitInfo(dfTraits$neonate_svl_length)
GetTraitInfo(dfTraits$teatnumber)
GetTraitInfo(dfTraits$weaning_bodylength)
GetTraitInfo(dfTraits$dispersal_age)
GetTraitInfo(dfTraits$home_range)
GetTraitInfo(dfTraits$home_range_indiv)
GetTraitInfo(dfTraits$pop_density)
GetTraitInfo(dfTraits$pop_grpsize)
GetTraitInfo(dfTraits$social_grpsize)
GetTraitInfo(dfTraits$median_lat)
GetTraitInfo(dfTraits$range_lat)
GetTraitInfo(dfTraits$GR_area)
GetTraitInfo(dfTraits$GR_maxlat)
GetTraitInfo(dfTraits$GR_minlat)
GetTraitInfo(dfTraits$GR_midrangelat)
GetTraitInfo(dfTraits$GR_maxlong)
GetTraitInfo(dfTraits$GR_minlong)
GetTraitInfo(dfTraits$GR_midrangelong)
GetTraitInfo(dfTraits$hupopden_min)
GetTraitInfo(dfTraits$hupopden_mean)
GetTraitInfo(dfTraits$hupopden_5p)
GetTraitInfo(dfTraits$hupopden_change)
GetTraitInfo(dfTraits$precip_mean)
GetTraitInfo(dfTraits$temp_mean)
GetTraitInfo(dfTraits$AET_mean)
GetTraitInfo(dfTraits$PET_mean)
#Factors
GetTraitInfo(dfTraits$activity_cycle)
GetTraitInfo(dfTraits$diet_breadth)
GetTraitInfo(dfTraits$habitat_breadth)
GetTraitInfo(dfTraits$terrestriality)
GetTraitInfo(dfTraits$trophic_level)
dfTraits$maturity_length <- NULL
dfTraits$imr_pyear <- NULL
dfTraits$mrdt <- NULL
dfTraits$weaning_bodylength <- NULL
dfTraits$dispersal_age <- NULL
dfPreCentroid <- merge(dfFiltered, dfTraits, by = "species_name")[, 1:8]
# Dataframe reorganization and renaming.
setnames(dfPreCentroid, "bin_uri.x", "bin_uri")
setnames(dfPreCentroid, "filtered_bin_size.x", "filtered_bin_size")
rm(dfFilteredSingle, dfBodyMass, dfForearmLength, dfHeadBodyLength, dfEyeOpeningAge, dfBmrRate, dfBmrMass, dfMaxLongevity, dfSexualMaturityAge, dfAdultSvlLength, dfMaturityLength, dfGrowthRate, dfImrPerYear,dfMrdt, dfMetabolicRate, dfFirstBirthAge, dfGestationLength, dfInterbirthInterval, dfLitterSize, dfLittersPerYear, dfNeonateBodyMass, dfNeonateHeadBodyLength, dfNeonateSvlLength, dfTeatNumber, dfWeaningAge, dfWeaningBodyMass, dfWeaningBodyLength, dfDispersalAge, dfHomeRange, dfHomeRangeIndividual, dfPopulationDensity, dfPopulationGroupSize, dfSocialGroupSize, dfLatitudeMedian, dfLatitudeRange, dfGrArea, dfGrMaxLat, dfGrMinLat, dfGrMidRangeLat, dfGrMaxLong, dfGrMinLong, dfGrMidRangeLong, dfHumanPopulationMin, dfHumanPopulationMean, dfHumanPopulation5p, dfHumanPopulationChange, dfPrecipitationMean, dfTemperatureMean, dfAETMean, dfPETMean, dfActivityCycle, dfDietBreadth, dfHabitatBreadth, dfTerrestriality, dfTrophicLevel)
rm(pantheriaMammalData, placentalMammalData, amnioteMammalData, anageMammalData, pantheriaTrait, amnioteTrait, placentalTrait, anageTrait)
rm(selectedTraits, missing, missingbm); rm( dfLatitudeSpecies, dfResolve, dfTrait)
save.image("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 2 July 04.RData")
setwd("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/rscripts")
### PACKAGES REQUIRED ###
# For data manipulation:
#install.packages("data.table")
library(data.table)
# For multiple sequence alignments:
#install.packages("ape")
library(ape)
#source("https://bioconductor.org/biocLite.R")
#biocLite("Biostrings")
library(Biostrings)
#biocLite("muscle")
library(muscle)
#install.packages("foreach")
library(foreach)
# Load the function(s) designed for this script:
source("RefSeqTrim.R")
#############################################################################################################################
# Subset dataframe to find BINs with more than one sequence.
dfLargeBins <- dfPreCentroid[filtered_bin_size > 1]
# If there is at least one BIN with more than one sequence...
if (nrow(dfLargeBins) > 0) {
# Remove gaps from the sequences.
dfPreCentroid[, nucleotides := gsub("-", "", nucleotides)]
# Subset out the BINs with more than 1 sequence.
dfCentroidSeqs <- dfPreCentroid[bin_uri %in% dfLargeBins$bin_uri]
# We also have to create another separate dataframe with BINs that only have one sequence, called dfSingletons.
dfSingletons <- dfPreCentroid[!bin_uri %in% dfLargeBins$bin_uri]
# We then take the dfCentroidSeqs sequences and group them by BIN.
largeBinList <- split(dfCentroidSeqs, by = "bin_uri")
# Convert all the sequences in largeBinList to DNAStringSet format for
# the multiple sequence alignment.
DNAStringSetList <- lapply(largeBinList, function(x) DNAStringSet(x$nucleotides))
# Name DNAStringSetList using the recordIDs.
for (i in seq(from = 1, to = length(unique(dfCentroidSeqs$bin_uri)), by = 1)) {
names(DNAStringSetList[[i]]) <- largeBinList[[i]]$recordID
}
# Align the sequences in each BIN using MUSCLE.
alignmentList <- lapply(DNAStringSetList, function(x) muscle::muscle(x, diags = TRUE, gapopen = -3000))
# Convert each BIN alignment to DNAbin format.
alignmentList <- lapply(alignmentList, function(x) as.DNAbin(x))
# Estimates the genetic distance between sequences in each BIN with the TN93 model.
distanceMatrixList <- lapply(alignmentList, function(x) dist.dna(x, model = "TN93", as.matrix = TRUE, pairwise.deletion = TRUE))
# Find the centroid sequence using the genetic distance matrix. It is the sequence in a BIN with minimum average pairwise distance to all other sequences in the BIN.
centroidSeqs <- sapply(distanceMatrixList, function(x) which.min(rowSums(x)))
centroidSeqs <- names(centroidSeqs)
centroidSeqs <- gsub("^.*\\.", "", centroidSeqs)
centroidSeqs <- as.numeric(centroidSeqs)
# Subset dfCentroidSeqs by the recordIDs of the centroid sequences.
dfCentroidSeqs <- dfCentroidSeqs[dfCentroidSeqs$recordID %in% centroidSeqs]
# Combine the singletons and centroid sequences into a new dataframe. Now each BIN has a representative sequence.
dfCentroidSeqs <- rbind(dfCentroidSeqs, dfSingletons)
} else {
# Centroid sequence selection not required if all BINs are singletons.
dfCentroidSeqs <- dfPreCentroid
}
# REFERENCE SEQUENCE TRIMMING #
# Trim the centroid sequences according to a standardized reference sequence. Currently, a standard length (658 bp) COI-5P sequence from
# Perca flavescens (yellow perch) is being used to trim Actinopterygii barcode sequences.
# Use the RefSeqTrim function to trim nucleotide sequences in a dataframe according to a given reference sequence.
dfCheckCentroidSeqs <- RefSeqTrim(dfCentroidSeqs)
dfCheckCentroidSeqs[,1:7]<- dfCentroidSeqs[,1:7]
# Remove objects that are not required for Section 4.
rm(alignmentList, centroidSeqs, i); rm(dfPreCentroid, dfLargeBins, dfSingletons); rm(largeBinList, distanceMatrixList, DNAStringSetList)
save.image("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 3 July 04.RData")
setwd("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/rscripts")
### PACKAGES REQUIRED ###
# For data manipulation:
#install.packages("data.table")
library(data.table)
#install.packages(stringr)
library(stringr)
# For multiple sequence alignments:
#install.packages("ape")
library(ape)
#source("https://bioconductor.org/biocLite.R")
#biocLite("Biostrings")
library(Biostrings)
#biocLite("muscle")
library(muscle)
library(foreach)
# Load the function(s) designed for this script:
source("RefSeqTrim.R")
source("RemoveSequences.R")
#############################################################################################################################
### QUALITY CHECK 1: GAPPY SEQUENCES ###
# Here, extremely gappy/ungappy sequences are removed. These sequences are assumed to contribute to misalignment of the
# sequences or may even be pseudogenes. Manual checking of the alignment is recommended.
# Determine the number of positions where an *internal* N or gap is found for each sequence.
dfCheckCentroidSeqs[, internal_gapN := str_count(nucleotides, c("[-+]"))]
# Which sequences are NOT within the range of mean number of gaps in the centroid sequences +/- 7? These represent extremely gappy sequences.
dfGappySeqs <- dfCheckCentroidSeqs[!internal_gapN %between% c(mean(internal_gapN) - 7, mean(internal_gapN) + 7)]
# Make sure outgroups are not included in the dfGappySeqs!
dfGappySeqs <- dfGappySeqs[!species_name %in% outgroups]
# Remove the gappy sequences from the original dfCentroidSeqs as we will be realigning these sequences again once troublesome cases are removed.
dfCentroidSeqs <- RemoveSequences(dfCentroidSeqs, dfGappySeqs$species_name)
### QUALITY CHECK 2: OUTLIERS ###
# Remove centroid sequences whose genetic distances to all other sequences fall outside the typical range of genetic divergence for this group of organisms.
# First, convert the sequences to DNAbin format so we can build a distance matrix.
DNABinNN <- DNAStringSet(dfCheckCentroidSeqs$nucleotides)
names(DNABinNN) <- dfCheckCentroidSeqs$species_name
DNABinNN <- as.DNAbin(DNABinNN)
# Then, we construct a pairwise distance matrix using the TN93 model.
distanceMatrix <- dist.dna(DNABinNN, model = "TN93", as.matrix = TRUE, pairwise.deletion = TRUE)
# Use the upper threshold of the IQR to detect outliers.
lowerQuantile <- quantile(distanceMatrix)[2]
upperQuantile <- quantile(distanceMatrix)[4]
iqr <- upperQuantile - lowerQuantile
upperThreshold <- (iqr * 1.5) + upperQuantile
# Remove 0 values so that these are not considered (when a species is compared to itself - the diagonal values).
distanceMatrix[distanceMatrix == 0] <- NA
# Convert to datatable.
dfOutliers <- as.data.table(distanceMatrix, keep.rownames = T)
# Rename the "rn" column (row names).
setnames(dfOutliers, "rn", "species_name")
# Identify BINs with no relatives within "typical" range of genetic divergence (i.e. all of their genetic distances are greater than 1.5 x IQR upper threshold.)
dfOutliers <- dfOutliers[, outlier := apply(.SD, 1, function(x) all(x > upperThreshold, na.rm = T))][outlier == TRUE]
# Make sure outgroups are not included in the outliers!
dfOutliers <- dfOutliers[!species_name %in% outgroups]
# If desired, remove the outliers from dfCentroidSeqs.
dfCentroidSeqs <- RemoveSequences(dfCentroidSeqs, dfOutliers$species_name)
### QUALITY CHECK 3: CLOSE NEIGHBOUR TAXONOMY ###
# Remove centroid sequences whose close neighbours are in a different order or family. Close neighbours can be determined
# from the distance matrix. They are sequences that are within a genetic distance of 0.05. If these neighbours are in a different
# order or family, this may be indicative of something weird going on in either the sequence data or taxonomic assignment.
dfGeneticDistance <- as.data.table(distanceMatrix)
# Convert the distance matrix to a datatable with the names of the species pairs and their distances.
dfGeneticDistance <- data.table(t(combn(names(dfGeneticDistance), 2)), distance = t(dfGeneticDistance)[lower.tri(dfGeneticDistance)])
setnames(dfGeneticDistance, old = c("V1", "V2"), new = c("species_1", "species_2"))
# Subset out all close neighbour pairings that share a genetic distance under 0.05 to any other sequence.
dfGeneticDistance <- dfGeneticDistance[distance < 0.05]
# Get the order and families names of the species from dfCentroidSeqs.
dfGeneticDistance <- merge(dfGeneticDistance, dfCentroidSeqs[, c(1, 5:6)], by.x = "species_1", by.y = "species_name")
dfGeneticDistance <- merge(dfGeneticDistance, dfCentroidSeqs[, c(1, 5:6)], by.x = "species_2", by.y = "species_name")
setnames(dfGeneticDistance, old = c("order_name.x", "family_name.x", "order_name.y", "family_name.y"),
new = c("order_1", "family_1", "order_2", "family_2"))
# Now, which orders do not match between order_1 and order_2?
dfMismatchOrders <- dfGeneticDistance[order_1 != order_2]
# Remove these species from dfCentroidSeqs if desired:
dfCentroidSeqs <- RemoveSequences(dfCentroidSeqs, c(unique(dfMismatchOrders$species_1), unique(dfMismatchOrders$species_2)))
# Now, which families do not match between family_1 and family_2?
dfMismatchFamilies <- dfGeneticDistance[family_1 != family_2]
# Remove these species from dfCentroidSeqs if desired:
dfCentroidSeqs <- RemoveSequences(dfCentroidSeqs, c(unique(dfMismatchFamilies$species_1), unique(dfMismatchFamilies$species_2)))
### OUTGROUP CHECK ###
# Which outgroups made it pass the filters? Remove them from dfCentroidSeqs to build a tree just using the ingroup
# (so that inclusion of outgroups in the tree building process doesn't affect the branch length estimates of the in-group).
dfGoodOutgroups <- dfCentroidSeqs[dfCentroidSeqs$species_name %in% outgroups]
# Remove the outgroups from dfCentroidSeqs and rename it to indicate that it does not include the outgroup (NO = no outgroup).
dfCentroidSeqsNO <- dfCentroidSeqs[!dfCentroidSeqs$species_name %in% outgroups]
# Now, re-trim and align the sequences without the outgroups.
dfCentroidSeqsNO <- RefSeqTrim(dfCentroidSeqsNO)
# Once finished, make sure to check over sequences/alignment, and make sure they are in the correct reading frame.
# Make sure to save the resulting alignments under a different name, or save in a new directory so they are not replaced.
# Now re-run the alignment including outgroups (pick outgroup species that are well represented and that serve as an appropriate
# outgroup to your taxa).
# Rename dfCentroidSeqs to indicate that it includes the outgroup (WO = with outgroup.)
dfCentroidSeqsWO <- dfCentroidSeqs
# Run the alignment with outgroups included.
dfCentroidSeqsWO <- RefSeqTrim(dfCentroidSeqsWO)
# Remove objects that are not required for Section 5.
rm(DNABinNN, iqr, lowerQuantile, upperQuantile, upperThreshold, distanceMatrix)
rm(dfCentroidSeqs, dfCheckCentroidSeqs, dfGappySeqs, dfGeneticDistance, dfOutliers, dfMismatchOrders, dfMismatchFamilies, dfGoodOutgroups)
save.image("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 4 July 04.RData")
setwd("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/rscripts")
#install.packages("ape")
#install.packages("phangorn")
#install.packages("seqinr")
#source("https://bioconductor.org/biocLite.R")
#biocLite("Biostrings")
library(ape)
library(phangorn)
library(seqinr)
library(Biostrings)
#Converting data table to DNAStringSet object
mammalDSA <- DNAStringSet(dfCentroidSeqsNO$nucleotides)
#Write dna file for dna string set
write.dna(mammalDSA, "mammals.DNA")
#Read  dna file
mammals <- read.dna("mammals.dna", format="interleaved")
#DNA to phyDAT format
mammals_phyDat <- phyDat(mammals, type = "DNA", levels = NULL)
#Compute pairwise distance
dm <- dist.ml(mammals_phyDat, model="JC69")
#NJ tree estimation
mammals_NJ  <- NJ(dm)
#Plot NJ tree
plot(mammals_NJ, main = "Neighbor Joining")
#Write Tree
write.tree(mammals_NJ, file="bootstrap_example.tree")
save.image("C:/Users/RalphArvin/Desktop/work-s2018/mammalsb/June 22/Sec 4b July 04.RData")
View(dfTraits)
setwd("C:/Users/imralpharvin/Desktop/work-s2018/mammalsb/rscripts")
#install.packages("data.table")
library(data.table)
# For phylogenetic tree manipulation and analysis:
#install.packages("adephylo")
library(adephylo)
#install.packages("ape")
library(ape)
#install.packages("caper")
library(caper)
#install.packages("phytools")
library(phytools)
# For statistical analysis/graphs:
#install.packages("car")
library(car)
#install.packages("plotly")
library(plotly)
#install.packages("Rmisc")
library(Rmisc)
# Load the function(s) designed for this script:
#install.packages("devtools")
library(devtools)
#install_github("helixcn/phylotools")
library(phylotools)
source("GetTraitInfo.R")
source("TestPhyloSig.R")
source("PGLS.R")
source("MergeAndPGLS.R")
#############################################################################################################################
# A phylogenetic tree containing branch length data for your species is required for this section.
# Read in your phylogenetic tree.
mainTree <- read.tree(file = "bootstrap_example.tree")
temp <- 1
while( temp <= length(mainTree$tip.label)){
mainTree$tip.label[temp] <- dfCentroidSeqsNO$species_name[as.numeric(mainTree$tip.label[temp])]
temp = temp + 1;
}
# Root the tree using your chosen outgroup species.
mainTree <- root(mainTree, outgroup = "Tachyglossus aculeatus", resolve.root = T)
### TRAIT: NUMBER OF NODES.
# Match mainTree with data subset. This will ensure the tree has only the tips we need for data analysis.
dfTraits <- dfTraits[match(mainTree$tip.label, dfTraits$species_name), ]
dfTraits[, number_of_nodes := distRoot(mainTree, method = "nNodes")]
### TRAIT: BRANCH LENGTHS.
# Let's calculate the sum of branch lengths now (from root to tip). These values will serve as our measurement of molecular evolution rate.
dfTraits[, branch_length := distRoot(mainTree, method = "patristic")]
# Get info about the branch lengths.
GetTraitInfo(dfTraits$branch_length)
# Range within which 95% of the values fall.
quantile(dfTraits$branch_length, probs = c(.025, .975))
# Take a closer look at branch length outliers. Some contaminated sequences might have STILL gotten through, so it is best to check!
# Using the IQR to detect statistical outliers.
lowerQuantile <- quantile(dfTraits$branch_length)[2]
upperQuantile <- quantile(dfTraits$branch_length)[4]
iqr <- upperQuantile - lowerQuantile
upperThreshold <- (iqr * 3) + upperQuantile
lowerThreshold <-  lowerQuantile - (iqr * 3)
dfShort <- dfTraits[branch_length < lowerThreshold][, c(1, 50:51)]
# Get the sequence information in case you want to BLAST the sequence (also, we aren't interested in outgroup species here,
# that's why we are using dfCentroidSeqsNO).
dfShort <- merge(dfShort, dfCentroidSeqsNO, by = "species_name")
# Do the same for the extreme long branches.
dfLong <- dfTraits[branch_length > upperThreshold][, c(1, 50:51)]
dfLong <- merge(dfLong, dfCentroidSeqsNO, by = "species_name")
# Remove from dataset, if desired.
dfTraits <- RemoveSequences(dfTraits, c(dfShort$species_name, dfLong$species_name))
### SINGLE VARIABLE REGRESSION ANALYSIS ###
# Running a single variable PGLS regression analysis for each trait to determine whether significance can be detected. If so, they will be included
# in the multivariable regression model selection process.
# First, make sure the trait data and phylo tree match (in case species were removed).
mainTree <- drop.tip(phy = mainTree, tip = mainTree$tip.label[!mainTree$tip.label %in% dfTraits$species_name])
dfTraits <- dfTraits[match(mainTree$tip.label, dfTraits$species_name), ]
GetTraitInfo(dfTraits$body_mass)
View(dfTraits)
